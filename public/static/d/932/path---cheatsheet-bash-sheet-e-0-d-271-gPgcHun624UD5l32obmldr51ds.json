{"data":{"markdownRemark":{"html":"<h1>Roi's BashSheet</h1>\n<ul>\n<li><code>#!/bin/bash</code> - lets the execution know with what to execute</li>\n</ul>\n<h2>Special Variables</h2>\n<ul>\n<li><code>$0</code> - The name of the Bash script.</li>\n<li><code>$1 - $9</code> - The first 9 arguments to the Bash script. (As mentioned above.)</li>\n<li><code>$#</code> - How many arguments were passed to the Bash script.</li>\n<li><code>$@</code> - All the arguments supplied to the Bash script.</li>\n<li><code>$?</code> - The exit status of the most recently run process.</li>\n<li><code>$$</code> - The process ID of the current script.</li>\n<li><code>$USER</code> - The username of the user running the script.</li>\n<li><code>$HOSTNAME</code> - The hostname of the machine the script is running on.</li>\n<li><code>$SECONDS</code> - The number of seconds since the script was started.</li>\n<li><code>$RANDOM</code> - Returns a different random number each time is it referred to.</li>\n<li><code>$LINENO</code> - Returns the current line number in the Bash script.</li>\n</ul>\n<h2>Variables</h2>\n<ul>\n<li><code>varaible=value</code> - To set a value for a variable. Remember, no spaces on either side of =</li>\n<li><code>Quotes \" '</code> - Double will do variable substitution, single will not.</li>\n<li><code>variable=$( command )</code> - Save the output of a command into a variable (example: <code>myvar=$( ls /etc | wc -l )</code>)</li>\n<li><code>export var1</code>- Make the variable var1 available to child processes.</li>\n<li><code>read varName</code> - Read input from the user and store it in the variable varName.</li>\n<li>\n<p><code>/dev/stdin</code> - A file you can read to get the STDIN for the Bash script (example: <code>echo roi | cat /dev/stdin</code>)</p>\n<ul>\n<li>STDIN - /dev/stdin or /proc/self/fd/0</li>\n<li>STDOUT - /dev/stdout or /proc/self/fd/1</li>\n<li>STDERR - /dev/stderr or /proc/self/fd/2</li>\n</ul>\n</li>\n<li>\n<p><code>let &#x3C;arithmetic expression></code> - Make a variable equal to an expression. (example: <code>let a=5+4</code> echo $a # 9)</p>\n<ul>\n<li><code>+, -, /*, /</code> - addition, subtraction, multiply, divide</li>\n<li><code>var++</code> - Increase the variable var by 1</li>\n<li><code>var--</code> - Decrease the variable var by 1</li>\n<li><code>%</code> -Modulus (Return the remainder after division)</li>\n</ul>\n</li>\n<li><code>expr item1 operator item2</code> - like let only print out the result of the expression.</li>\n<li><code>$(( expression ))</code> - Return the result of the expression. <em>recommended</em></li>\n<li><code>${#var}</code> - Return the length of the variable var.</li>\n</ul>\n<h2>Statements</h2>\n<ul>\n<li>\n<p><code>if statement</code></p>\n<pre><code class=\"language-bash\">if [ &#x3C;some test> ]\nthen\n&#x3C;commands>\nelif [ &#x3C;some test> ] \nthen\n&#x3C;different commands>\nelse\n&#x3C;other commands>\nfi\n</code></pre>\n</li>\n<li>\n<p><code>case statement</code></p>\n<pre><code class=\"language-bash\">case &#x3C;variable> in\n&#x3C;pattern 1>)\n&#x3C;commands>\n;;\n&#x3C;pattern 2>)\n&#x3C;other commands>\n;;\nesac\n</code></pre>\n</li>\n</ul>\n<h2>loops</h2>\n<ul>\n<li>\n<p><code>while loop</code></p>\n<pre><code class=\"language-bash\">while [ &#x3C;some test> ]\ndo\n&#x3C;commands>\ndone\n</code></pre>\n</li>\n<li>\n<p><code>until loop</code></p>\n<pre><code class=\"language-bash\">until [ &#x3C;some test> ]\ndo\n&#x3C;commands>\ndone\n</code></pre>\n</li>\n<li>\n<p><code>for loop</code></p>\n<pre><code class=\"language-bash\">for var in &#x3C;list>\ndo\n&#x3C;commands>\ndone\n</code></pre>\n</li>\n<li><code>ranges</code> - can provide a list for for loops (example: <code>for value in {1..5} do...</code>)</li>\n<li><code>break</code> - leave the loop strait away</li>\n<li><code>continue</code> - continue to the next iteration of the loop</li>\n<li><code>select loop</code> - like for loop with <code>select</code> instead of <code>for</code>. Display a simple menu system for selecting items from a list.</li>\n</ul>\n<h2>Test</h2>\n<p><code>test</code> - command is the command line version of <code>[]</code> in bash scripts</p>\n<ul>\n<li><code>! EXPRESSION</code> - The EXPRESSION is false.</li>\n<li><code>-n STRING</code> - The length of STRING is greater than zero.</li>\n<li><code>-z STRING</code> - The lengh of STRING is zero (ie it is empty).</li>\n<li><code>STRING1 = STRING2</code> - STRING1 is equal to STRING2</li>\n<li><code>STRING1 != STRING2</code> - STRING1 is not equal to STRING2</li>\n<li><code>INTEGER1 -eq INTEGER2</code> - INTEGER1 is numerically equal to INTEGER2</li>\n<li><code>INTEGER1 -gt INTEGER2</code> - INTEGER1 is numerically greater than INTEGER2</li>\n<li><code>INTEGER1 -lt INTEGER2</code> - INTEGER1 is numerically less than INTEGER2</li>\n<li><code>-d FILE</code>\t- FILE exists and is a directory.</li>\n<li><code>-e FILE</code>\t- FILE exists.</li>\n<li><code>-r FILE</code>\t- FILE exists and the read permission is granted.</li>\n<li><code>-s FILE</code>\t- FILE exists and it's size is greater than zero (ie. it is not empty).</li>\n<li><code>-w FILE</code>\t- FILE exists and the write permission is granted.</li>\n<li><code>-x FILE</code> - FILE exists and the execute permission is granted.</li>\n<li><code>and</code> - &#x26;&#x26;</li>\n<li><code>or</code> - ||</li>\n</ul>\n<h2>Functions</h2>\n<ul>\n<li></li>\n</ul>\n<pre><code class=\"language-bash\">function_name () {\n  &#x3C;commands>\n}\n# or\nfunction function_name {\n  &#x3C;commands>\n}\n</code></pre>\n<ul>\n<li>arguments are passed with <code>$1 - $9</code></li>\n<li><code>return &#x3C;value></code> - Exit the function with a return status of value. </li>\n<li>\n<p><code>local var_name=&#x3C;var_value></code> - Create a local variable within a function.</p>\n<pre><code class=\"language-bash\"># important example\nprint_something () {\necho Hello $1 # we can get this with evaluating the function\nreturn 5 # status code\n}\n</code></pre>\n</li>\n</ul>\n<h1>in order to get result of the output of a function into a variable</h1>\n<p>lines<em>in</em>file () {\ncat $1 | wc -l\n}\nnum<em>lines=$( lines</em>in_file $1 )</p>\n<pre><code>## AWK - text processor\n* `awk '{}' FILE` - this is the template. Inside the '{}' we can give awk a lot of information\n  * `'{ print }` - prints every line to the screen\n  * `'{ print leanth($1),$2.$3 }` - print length of first colums (`,` means) space second column (`.` means) *no space* third column of every line\n  * `'\\[0-9]$\\ { print }` - print every line that has the regex in between `\\`. this instance it is lines that end with a number.\n  * `{ if($1 ~ /test/) print }` - print line only if the first column is equeal to the regex exp (test here)\n  * `awk -F\":\" '{}' FILE` - change the delimeter with -F (here to :)\n  * `awk 'NR==1,NR==10{ printf \"%-8s %3d\\n, $1, $3 }...'` - print between lines 1 - 10 with specific format (not explained)\n  * `awk 'BEGIN { print roi } { print }` - would start by printing roi and after printing every row\n  * `awk '/test/ BEGIN { sum=0, count=0, print roi } { sum+=$1, count++ } { print } END { print count }'` - BEGIN would do once before processing every line. End would do once after all processing. We can create a variable name counter and add to it every line.\n\n\n## SED - text processor\n* `sed 's/A/B/${flag}' ${file}` - sed substitutes every line's *first* A by B (A can be a regex)\n  * `sed -i...` - change the original file\n  * `s/A/B/g` - means change globally (all A in line by B's)\n  * `s/[0-9]/(&#x26;)/g` - change every number by a parenthesis version of himself (&#x26; holds the found regex)\n  * `s/[0-9]*/(&#x26;)/g` - searches for *0* or more occurances of numbers 0-9.\n  * `s/[0-9][0-9]*/(&#x26;)/g`- searches for *1* or more occurances of numbers 0-9. \n</code></pre>","frontmatter":{"path":"/cheatsheet/BashSheet","title":"BashSheet"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}