{"data":{"markdownRemark":{"html":"<h1>Roi's HaskellSheet</h1>\n<h2>haskell is a <strong>Purely Functional Programming</strong> language-</h2>\n<ul>\n<li>declarative programming paradigm - <strong>NO variables</strong>, <strong>Only Experssions</strong>.</li>\n<li>when there are no variables there is no state to change, function have <strong>NO Side Effects</strong></li>\n<li>referential transparency - pure functions <strong>output depends solely on their input</strong></li>\n<li><strong>functional functions are ones we can memoize</strong> - only calculate if we didn't in the past.</li>\n</ul>\n<h2>haskell is <strong>Lazy</strong> (as opposed to eager and memoized)</h2>\n<ul>\n<li>for example infinite list [1,2..] is only evaluated when needed</li>\n</ul>\n<h2>haskell is <strong>strongly statically typed</strong> with <strong>type inference</strong></h2>\n<ul>\n<li>automatic detection of the data type of an expression</li>\n</ul>\n<h2>ghci - glasgow haskell compiler</h2>\n<ul>\n<li><code>ghci 2>&#x26;1 | HsColour -tty</code> - open ghci with colour</li>\n<li>:set prompt \"haskell> \"</li>\n<li>:l <file path> (name ends with .hs)</li>\n<li>:m <module name></li>\n</ul>\n<h2>stack - like pip/npm/sbt etc'</h2>\n<ul>\n<li><code>stack setup</code> - makes a local copy of ghc</li>\n<li><code>stack execute #{executable}</code> - usually the same name as the project</li>\n<li><code>stack test</code></li>\n<li><code>stack ghci</code> - loads all library to ghci</li>\n</ul>\n<h2>Association</h2>\n<ul>\n<li>\n<p>haskell is left associative meaning:</p>\n<ul>\n<li><code>f a b c</code> is the same as <code>(((f a) b) c)</code></li>\n</ul>\n</li>\n<li>\n<p>to fix that we can use <code>$</code> which makes stuff right assosiative</p>\n<ul>\n<li>\n<p><code>f $ a $ b $ c</code></p>\n<pre><code class=\"language-haskell\">ghci> sqrt 3 + 4 + 9\n14.732050807568877\nghci> sqrt $ 3 + 4 + 9\n4.0\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Parametricity</h2>\n<ul>\n<li>It is more about modularity and correctness than it is about generalizing for code reuse</li>\n<li>\n<p>why should we use parametrization and not specific types? isn't it overgeneralizing?</p>\n<ul>\n<li>No becuase otherwise we expose too much information to the function that we cannot reason about when looking at the function signature</li>\n<li>parametric definition isn't just for code reuse. We are also limiting the amount of data we need to keep in our head in order to work on this function</li>\n<li>nice twitter account to learn <a href=\"https://twitter.com/parametricity?lang=en\">https://twitter.com/parametricity?lang=en</a></li>\n</ul>\n</li>\n</ul>\n<h2>Functions</h2>\n<ul>\n<li>Functions use Arrow notation</li>\n<li>\n<p>Functions are curried by default</p>\n<pre><code class=\"language-haskell\">-- two ways to create functions:\n-- with parameters\nadd3 x y z = x + y + z\n-- with lambda functions\nadd3_2 = \\x -> \\y -> \\z -> x + y + z\n</code></pre>\n</li>\n</ul>\n<h2>Composition of functions</h2>\n<pre><code class=\"language-haskell\">-- haskell has a nice notation to use composition with `.`\n(.) :: (b -> c) -> (a -> b) -> a -> c  \nf . g = \\x -> f (g x) \n\n-- example (with lambda function)\nghci> map (\\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]  \n[-5,-3,-6,-7,-3,-2,-19,-24]  \nghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]  \n[-5,-3,-6,-7,-3,-2,-19,-24]  \n</code></pre>\n<h2>if else and guarded notation (can be skipped)</h2>\n<pre><code class=\"language-haskell\">signum :: Int -> Int\nsignum n = if n &#x3C; 0 then -1 else\n             if n == 0 then 0 else 1\n\nabs n | n > 0 = n\n      | otherwise = -n\n</code></pre>\n<h2>pattern matching</h2>\n<pre><code class=\"language-haskell\">type Bool = True | False\n\nnegate :: Bool -> Bool\nnegate True = False\nnegate False = True\n\nsayNumUpTo5 :: (Integral a) => a -> String\nsayNumUpTo5 1 = \"One\"\nsayNumUpTo5 2 = \"Two\"\nsayNumUpTo5 3 = \"Three\"\nsayNumUpTo5 4 = \"Four\"\nsayNumUpTo5 5 = \"Five\"\nsayNumUpTo5 _ = \"Not between 1 and 5!\"\n</code></pre>\n<h2>Type Synonyms</h2>\n<pre><code class=\"language-haskell\">-- String is just an array of chars\ntype String = [Char]\n-- lets define a phonebook type\ntype PhoneBook = [(String, String)]\n-- Its not exectly understandable yet. What are those Strings?\n-- lets make it better\ntype PhoneNumber = String\ntype Name = String\n-- remember haskell is a pure language, can't redefine types/ variables\ntype PhoneBook2 = [(Name,PhoneNumber)]\n-- much better!\n</code></pre>\n<h2>Data Types</h2>\n<pre><code class=\"language-haskell\">-- algebraic data types\n-- Lets make new Types with type constructors:\ndata Bool = False | True\ndata Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)\n-- Circle and Rectangle are data constructors\n-- for example circle type is:\n-- Circle :: Float -> Float -> Float -> Shape\n-- The deriving keyword is a way to inherit properties from a class. \n-- It is needed if we want to print, More about that later \n\n-- Record syntex: \ndata Car = Car {company :: String, model :: String, year :: Int} deriving (Show, Read, Eq)\ndata Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)\n\n-- type parameters\ndata Maybe a = Nothing | Just a\n-- where Maybe is a type constructor and a is the parameter\n\n-- recursive data types structures\ndata List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)\n</code></pre>\n<h2>Type Classes</h2>\n<pre><code class=\"language-haskell\">-- kind of like interface/ trait, used for inheritance\nclass Eq a where  \n(==) :: a -> a -> Bool  \n(/=) :: a -> a -> Bool  \nx == y = not (x /= y)  \nx /= y = not (x == y)\n\n-- if we had a data type of traffic light\ndata TrafficLight = Red | Yellow | Green\n-- we could derive if we had a basic implementation in the class\n-- orrrrr\n-- we could just make an instance of Eq for TrafficLight\ninstance Eq TrafficLight where  \nRed == Red = True  \nGreen == Green = True  \nYellow == Yellow = True  \n_ == _ = False\n\n-- full example:\nimport Control.Monad\n\nclass YesNo a where\n    yesno :: a -> Bool\n\ninstance YesNo Int where\n    yesno 0 = False\n    yesno _ = True\n\ninstance YesNo Bool where\n    yesno = id\n\ninstance YesNo [a] where\n    yesno [] = False\n    yesno _ = True\n\ninstance YesNo (Maybe a) where\n    yesno (Just _) = True\n    yesno Nothing = False\n\n-- a class can inherit from another class\n-- here is a definition of Ord class\nclass  (Eq a) => Ord a  where\n    compare              :: a -> a -> Ordering\n    (&#x3C;), (&#x3C;=), (>=), (>) :: a -> a -> Bool\n    max, min             :: a -> a -> a\n-- Ord class inherits from eq class\nclass  (Num a, Ord a) => Real a  where\n    -- | the rational equivalent of its real argument with full precision\n    toRational          ::  a -> Rational\n-- Real class inherits form Num and Ord class\n</code></pre>\n<h2>NewType (can be skipped)</h2>\n<pre><code class=\"language-haskell\">-- newtype - a lazier version of Type that is restricted to just one constructor with one field\ndata CoolBool = CoolBool { getCoolBool :: Bool }\nhelloMe :: CoolBool -> String  \nhelloMe (CoolBool _) = \"hello\"\n\nnewtype CoolBool2 = CoolBool2 { getCoolBool2 :: Bool }\nhelloMe2 :: CoolBool2 -> String  \nhelloMe2 (CoolBool2 _) = \"hello\"\n\n-- with newtype the compiler doesnt need to find the type for the function, it knows it can only be a Bool\nghci> helloMe undefined  \n\"*** Exception: Prelude.undefined\nCallStack (from HasCallStack):\n  error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err\n  undefined, called at &#x3C;interactive>:3:9 in interactive:Ghci3\"\nghci> helloMe2 undefined  \n\"hello\"\n</code></pre>\n<ul>\n<li>\n<p>type vs newtype vs data</p>\n<ul>\n<li>type for making synonyms : <code>type IntList = [Int]</code> can be used like <code>([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])</code></li>\n<li>The newtype keyword is for taking existing types and wrapping them in new types, mostly so that it's easier to make them instances of certain type classes. When we use newtype to wrap an existing type, the type that we get is separate from the original type. If we make the following newtype : <code>newtype CharList = CharList { getCharList :: [Char] }</code></li>\n<li>The data keyword is for making your own data types and with them, you can go hog wild. They can have as many constructors and fields as you wish and can be used to implement any algebraic data type by yourself. Everything from lists and Maybe-like types to trees.</li>\n</ul>\n</li>\n<li>summary : If you just want your type signatures to look cleaner and be more descriptive, you probably want type synonyms. If you want to take an existing type and wrap it in a new type in order to make it an instance of a type class, chances are you're looking for a newtype. And if you want to make something completely new, odds are good that you're looking for the data keyword.</li>\n</ul>\n<h2>derivitives (deriving for types)</h2>\n<ul>\n<li>Eq</li>\n<li>Ord</li>\n<li>Enum</li>\n<li>Bounded</li>\n<li>Show</li>\n<li>Read</li>\n</ul>\n<h2>list comprehension (can be skipped)</h2>\n<pre><code class=\"language-haskell\">-- [result for each input | input A &#x3C;-, input B &#x3C;- ..., filter A > ?, filter B\n\n-- examples:\n-- a version of length\nghci> sum [1 | _ &#x3C;- [1,2,3,4,5]]\n5\n-- remove all except upper case\nghci> [ c | c &#x3C;- \"AbCdE\", c `elem` ['A'..'Z']]\n\"ACE\"\n-- get all products of 2 lists that are above 50\nghci> [ x*y | x &#x3C;- [2,5,10], y &#x3C;- [8,10,11], x*y > 50]  \n[55,80,100,110]\n</code></pre>\n<h2>Where &#x26; Let in scoping (can be skipped)</h2>\n<pre><code class=\"language-haskell\">-- both are they same except scoping in guard notation. \n-- where is for all guards wheres let in is individual\n-- basically choose one you prefer and use it\n-- i like let in :)\nmultiples x = \n    map mult [1..10]\n    where mult n = n * x\n\nmultiples2 x =\n    let mult n = n * x\n    in map mult [1..10]\n\nlistStats m =\n    \"total: \" ++ show total ++ \", avg: \" ++ show avg\n    where numbers = [1 .. m]\n          total = sum numbers\n          avg = total / m\n\nlistStats2 m =\n    let numbers = [1 .. m]\n        total = sum numbers\n        avg = total / m\n    in \"total: \" ++ show total ++ \", avg: \" ++ show avg\n</code></pre>\n<h2>Functors</h2>\n<p>things we can map over</p>\n<pre><code class=\"language-haskell\">class Functor f where\n    fmap :: (a -> b) -> f a -> f b\n\n(&#x3C;$>) :: (Functor f) => (a -> b) -> f a -> f b  \nf &#x3C;$> x = fmap f x\n\ninstance Functor Maybe where  \n    fmap f (Just x) = Just (f x)  \n    fmap f Nothing = Nothing  \n\n-- maybe example:\nfmap (*3) (Just 5)\n-- &#x3C;$> is fmap infix operator\n(*3) &#x3C;$> Just 5\n\n-- Functor laws\n-- Functors must preserve identity morphisms\nfmap id = id\n-- Functors preserve composition of morphisms\nfmap (f . g) F = fmap f (fmap g F)\n</code></pre>\n<h2>Applicative Functors (can be skipped)</h2>\n<p>adding functionality to function with a way to map over with applicative mapping functions </p>\n<pre><code class=\"language-haskell\">class (Functor f) => Applicative f where  \n    pure :: a -> f a  \n    (&#x3C;*>) :: f (a -> b) -> f a -> f b  \n\n-- Maybe example:\n\n--  Applicative functors are there if we want to use as a mapping function (Just *3) instead *3 to map over\ninstance Applicative Maybe where  \n    pure = Just  \n    Nothing &#x3C;*> _ = Nothing  \n    (Just f) &#x3C;*> something = fmap f something\n\n-- three examples that are all the same:\n-- normal functor properties usage (fmap)\nfmap (++) (Just \"johntra\") &#x3C;*> Just \"volta\"\n-- inline data type of fmap = &#x3C;$>\n(++) `fmap` Just \"johntra\" &#x3C;*> Just \"volta\"\n(++) &#x3C;$> Just \"johntra\" &#x3C;*> Just \"volta\"\n-- applicative functor usage\nJust (++) &#x3C;*> Just \"johntra\" &#x3C;*> Just \"volta\"\n\n-- List [] example:\n\ninstance Applicative [] where  \n    pure x = [x]  \n    fs &#x3C;*> xs = [f x | f &#x3C;- fs, x &#x3C;- xs]\n\nghci> pure \"Hey\" :: [String]  \n[\"Hey\"]  \nghci> pure \"Hey\" :: Maybe String  \nJust \"Hey\"\nghci> [(*0),(+100),(^2)] &#x3C;*> [1,2,3]  \n[0,0,0,101,102,103,1,4,9]  \nghci> [(+),(*)] &#x3C;*> [1,2] &#x3C;*> [3,4]  \n[4,5,5,6,3,4,6,8]\n\n-- IO example:\n\ninstance Applicative IO where  \npure = return  \na &#x3C;*> b = do  \n    f &#x3C;- a  \n    x &#x3C;- b  \n    return (f x)  \n\nmyAction :: IO String  \nmyAction = (++) &#x3C;$> getLine &#x3C;*> getLine  \nmain = do  \na &#x3C;- (++) &#x3C;$> getLine &#x3C;*> getLine  \nputStrLn $ \"The two lines concatenated turn out to be: \" ++ a  \n</code></pre>\n<h2>Monoid typeclass</h2>\n<p>*, ++ are monoids because they both have identity values and are associative. (1 and [])\n** associative means that (1 * 2) * 3 = 1 * (2 * 3)</p>\n<pre><code class=\"language-haskell\">-- \nclass Monoid m where  \n    mempty :: m  \n    mappend :: m -> m -> m  \n    mconcat :: [m] -> m  \n    mconcat = foldr mappend mempty\n\n-- this infix synonym for mappend is found in Data.Monoid\nx &#x3C;> y = mappend x y\n\n-- Monoid laws:\n-- Identity law (&#x3C;> is like `mappend`)\n-- x &#x3C;> mempty = x\n-- mempty &#x3C;> x = x\n-- Associativity\n-- (x &#x3C;> y) &#x3C;> z = x &#x3C;> (y &#x3C;> z)\n</code></pre>\n<h2>Monad typeclass</h2>\n<p>adding functionality to functors with ability to map over with function that takes a normal input and outputs a functor</p>\n<pre><code class=\"language-haskell\">class Monad m where  \n    return :: a -> m a  \n  \n    (>>=) :: m a -> (a -> m b) -> m b  \n  \n    (>>) :: m a -> m b -> m b  \n    x >> y = x >>= \\_ -> y  \n  \n    fail :: String -> m a  \n    fail msg = error msg  \n\n-- maybe example\n\ninstance Monad Maybe where  \n    return x = Just x  \n    Nothing >>= f = Nothing  \n    Just x >>= f  = f x  \n    fail _ = Nothing  \n\n-- List example\n\ninstance Monad [] where  \n    return x = [x]  \n    xs >>= f = concat (map f xs)  \n    fail _ = []  \n\n-- 3 ways to use the monad:\n-- bind operator (monadic experssion)\nghci> [1,2] >>= \\n -> ['a','b'] >>= \\ch -> return (n,ch)  \n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n\n-- do notation\nlistOfTuples :: [(Int,Char)]  \nlistOfTuples = do  \nn &#x3C;- [1,2]  \nch &#x3C;- ['a','b']  \nreturn (n,ch)\n\n-- list comprehension\nghci> [ (n,ch) | n &#x3C;- [1,2], ch &#x3C;- ['a','b'] ]  \n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]  \n\n-- Monad laws:\n\n-- left identitiy - return x >>= f is the same damn thing as f x\n-- (return x) >>= f == f x\nghci> return 3 >>= (\\x -> Just (x+100000))  \nJust 100003  \nghci> (\\x -> Just (x+100000)) 3  \nJust 100003  \n\n-- right identity - m >>= return is no different than just m\n-- m >>= return == m\nghci> Just \"move on up\" >>= (\\x -> return x)  \nJust \"move on up\"  \nghci> [1,2,3,4] >>= (\\x -> return x)  \n[1,2,3,4]  \nghci> putStrLn \"Wah!\" >>= (\\x -> return x)  \nWah!\n\n-- associativity - Doing (m >>= f) >>= g is just like doing m >>= (\\x -> f x >>= g)\n-- (m >>= f) >>= g == m >>= (\\x -> f x >>= g)\n((return (0,0) >>= landRight 2) >>= landLeft 2) >>= landRight 2  \nreturn (0,0) >>= (\\x -> \nlandRight 2 x >>= (\\y -> \nlandLeft 2 y >>= (\\z -> \nlandRight 2 z)))  \n</code></pre>\n<h2>do notation</h2>\n<pre><code class=\"language-haskell\">import Data.Maybe\n\n-- do notation uses bind >>= with nicer syntax\ngreetingStr :: Maybe String\ngreetingStr = do\n   str1 &#x3C;- Just \"Hello \"\n   str2 &#x3C;- Just \"World\"\n   Just (str1 ++ str2)\n\n-- bind >>= is like `flatMap` for monads\ngreetingStr2 :: Maybe String\ngreetingStr2 =\n   Just \"Hello \" >>= \\str1 ->\n   Just \"World\" >>= \\str2 ->\n   Just (str1 ++ str2)\n\n-- if there is no backwards arrow &#x3C;-, means we ignore the result of the function\ngreetingAction :: IO ()\ngreetingAction = do\n   putStr \"Hello \"\n   putStr \"World\"\n   putStrLn \"\"\n\n-- then >> operand is like bind >>= except it ignores input\ngreetingAction :: IO ()\ngreetingAction = \n    putStr \"Hello \" >>\n    putStr \"World\" >>\n    putStrLn \"\"\n</code></pre>","frontmatter":{"path":"/cheatsheet/HaskellSheet","title":"HaskellSheet"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}